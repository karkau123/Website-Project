{
    "id": "os",
    "name": "Operating Systems",
    "icon": "<svg class=\"card-icon\" style=\"color: #38bdf8;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"48\" height=\"48\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"2\" y=\"2\" width=\"20\" height=\"20\" rx=\"2.18\" ry=\"2.18\"></rect><line x1=\"7\" y1=\"2\" x2=\"7\" y2=\"22\"></line><line x1=\"17\" y1=\"2\" x2=\"17\" y2=\"22\"></line><line x1=\"2\" y1=\"12\" x2=\"22\" y2=\"12\"></line><line x1=\"2\" y1=\"7\" x2=\"7\" y2=\"7\"></line><line x1=\"2\" y1=\"17\" x2=\"7\" y2=\"17\"></line><line x1=\"17\" y1=\"17\" x2=\"22\" y2=\"17\"></line><line x1=\"17\" y1=\"7\" x2=\"22\" y2=\"7\"></line></svg>",
    "description": "Fundamental concepts of operating systems, process management, memory management, and concurrency.",
    "topics": [
        {
            "name": "Introduction to OS",
            "subtopics": [
                {
                    "name": "What is an Operating System?",
                    "completed": true,
                    "details": "<p>An <strong>operating system (OS)</strong> is the foundational software that acts as the central nervous system of a computer. It's a complex and sophisticated suite of system software that meticulously manages and orchestrates all of the computer's hardware and software resources. Furthermore, it provides a rich set of common services that are essential for the execution of computer programs. In essence, the OS functions as a crucial <strong>intermediary</strong>, bridging the gap between the user and the intricate, low-level workings of the computer hardware. This abstraction layer simplifies the user experience, making the computer system not only convenient to use but also highly efficient in its operations.</p><img src='images/OS.png' alt='Operating System Diagram' style='max-width: 100%; height: auto; display: block; margin: 1rem auto;'><p>The primary objectives of an operating system are threefold: to make the computer system approachable and easy to use, to manage and utilize the computer's hardware resources in the most effective manner possible, and to provide a stable and consistent environment in which users can seamlessly interact with the machine. A key role of the operating system is that of a <strong>resource allocator</strong>. A modern computer system is endowed with a multitude of resources that are called upon to solve a vast array of computational problems. These resources include, but are not limited to, CPU time, memory space, file-storage space, and a diverse range of input/output (I/O) devices. The operating system acts as the vigilant manager of these resources, adjudicating the numerous and often conflicting requests from various programs and users. This entails making critical decisions on how to allocate these resources to specific applications and users to ensure the computer system operates efficiently, fairly, and without conflicts.</p><h3>Core Functions of an Operating System</h3><p>The multifaceted responsibilities of an operating system can be categorized into several key functional areas. These core functions work in concert to provide a stable and high-performing computing environment.</p><h4>Process Management</h4><p>In the context of an operating system, a <strong>process</strong> is an instance of a computer program that is being executed. Modern operating systems are designed to handle numerous processes concurrently, creating the illusion of simultaneous execution. The OS is tasked with managing the entire lifecycle of each process, from its creation to its eventual termination. This critical function involves several key activities including <strong>process scheduling</strong> (deciding which process gets to use the CPU and for how long using algorithms like FCFS, SJN, and Round Robin), <strong>process synchronization</strong> (ensuring shared resources are accessed in a controlled manner), and <strong>deadlock handling</strong>.</p><h4>Memory Management</h4><p>Memory is a finite and precious resource, and its efficient management is paramount to system performance. The operating system is the ultimate authority on memory allocation and deallocation. Key aspects of memory management include <strong>memory allocation</strong>, <strong>memory protection</strong> to prevent processes from interfering with each other, and <strong>virtual memory</strong>, a technique that uses a portion of the hard disk as an extension of the main memory to run large programs.</p><h4>File System Management</h4><p>The operating system provides a structured and logical view of the information stored on secondary storage devices. This is achieved through the implementation of a <strong>file system</strong>. The OS's responsibilities include maintaining a <strong>file and directory structure</strong>, providing a standard set of <strong>file operations</strong> (create, read, write, delete), and implementing <strong>access control</strong> to ensure data security.</p><h4>I/O Device Management</h4><p>A computer system comprises a wide variety of input/output (I/O) devices. The operating system is responsible for managing the communication and interaction between the CPU and these peripheral devices. This is accomplished through the use of <strong>device drivers</strong>, which are specialized software components that understand a device's specific protocols, and <strong>interrupt handling</strong>, which allows the CPU to efficiently manage requests from I/O devices.</p><h3>The Kernel: The Heart of the OS</h3><p>The <strong>kernel</strong> is the core component of an operating system. It has complete control over everything in the system. It is the first program loaded on start-up, and it handles the rest of the start-up as well as input/output requests from software, translating them into data-processing instructions for the central processing unit. It handles memory and peripherals like keyboards, monitors, printers, and speakers.</p><p>There are different architectural approaches to kernel design:</p><ul><li><strong>Monolithic Kernels:</strong> In this approach, the entire operating system—including the file system, memory management, device drivers, and system calls—runs in kernel space, a single, large process. This design can lead to very efficient performance, as communication between components is fast. Examples include the Linux kernel and traditional Unix kernels. However, a bug in one part of the kernel can crash the entire system.</li><li><strong>Microkernels:</strong> In contrast, a microkernel is a much smaller kernel that provides only the most basic functionalities, such as process scheduling and inter-process communication. Other services, like file systems and device drivers, run in user space as separate processes. This makes the system more modular and robust—a failing driver won't bring down the whole OS. Examples include QNX and Mach. The trade-off is often a performance overhead due to the increased communication between user-space processes and the kernel.</li><li><strong>Hybrid Kernels:</strong> These kernels attempt to combine the best of both worlds. They have a microkernel architecture but keep some additional services in kernel space for performance reasons. macOS and Windows NT are examples of hybrid kernels.</li></ul><h3>The Boot Process</h3><p>The process of starting a computer is known as <strong>booting</strong>. When you turn on your computer, the first thing that happens is the execution of a program stored in the computer's firmware, either the <strong>BIOS</strong> (Basic Input/Output System) or the newer <strong>UEFI</strong> (Unified Extensible Firmware Interface). This firmware performs a <strong>Power-On Self-Test (POST)</strong> to check that the computer's hardware is working correctly. After the POST, the firmware looks for a boot loader on a storage device (like a hard drive or SSD). The <strong>boot loader</strong> is a small program whose job is to load the main operating system kernel into memory. Once the kernel is loaded, it takes over and initializes the rest of the operating system, loading drivers and starting up system services and the user interface.</p><h3>Types of Operating Systems</h3><p>Operating systems can be broadly classified based on their capabilities:</p><ul><li><strong>Single-user, Multi-tasking:</strong> Allows a single user to run multiple applications concurrently (e.g., Microsoft Windows, macOS).</li><li><strong>Multi-user:</strong> Allows multiple users to access the computer's resources simultaneously (e.g., Linux, Unix).</li><li><strong>Real-time Operating Systems (RTOS):</strong> Designed for systems where timing is critical, such as in industrial control and robotics.</li><li><strong>Distributed Operating Systems:</strong> These systems manage a group of independent computers and make them appear to be a single computer, allowing for resource sharing and increased fault tolerance.</li><li><strong>Mobile Operating Systems:</strong> Tailored for mobile devices like smartphones and tablets (e.g., Android, iOS), optimized for touch interfaces and power efficiency.</li><li><strong>Embedded Operating Systems:</strong> These are specialized OSes designed to perform a specific task for a device that is not a traditional computer. They are found in cars, digital cameras, and home appliances.</li></ul><h3>Operating System Security</h3><p>Security is one of the most critical aspects of an operating system. The OS must protect the computer system from a variety of threats, including malware, unauthorized access, and data breaches. Key security features provided by the OS include:</p><ul><li><strong>Authentication:</strong> This is the process of verifying the identity of a user. It is typically done through usernames and passwords, but can also involve biometrics (fingerprints, facial recognition) or security tokens.</li><li><strong>Authorization and Access Control:</strong> Once a user is authenticated, the OS must determine what resources they are authorized to access. This is managed through access control lists (ACLs) and permissions that specify which users can read, write, or execute files.</li><li><strong>Data Encryption:</strong> Many operating systems now offer built-in tools to encrypt the contents of a storage drive, making the data unreadable without the correct decryption key. This protects data even if the physical device is stolen.</li><li><strong>Firewalls:</strong> The OS often includes a software firewall that monitors incoming and outgoing network traffic and blocks suspicious connections, helping to prevent unauthorized access to the system from a network.</li></ul>"
                },
                {
                    "name": "Types of Operating Systems",
                    "completed": false,
                    "details": "There are several types of operating systems, each designed for specific purposes and environments. \n1. Batch OS: Processes are bundled together in a 'batch' and processed sequentially. Users do not interact directly with the system. \n2. Time-Sharing (or Multitasking) OS: Allows multiple users to share the computer simultaneously. The CPU's time is shared among multiple processes, giving an illusion of parallel execution. \n3. Real-Time OS (RTOS): Used in systems where time constraints are critical, such as industrial control systems or medical devices. RTOS guarantees that tasks complete within specific deadlines. There are hard real-time systems and soft real-time systems. \n4. Distributed OS: Manages a group of independent computers and makes them appear to be a single computer. Users can access resources from any machine in the network. \n5. Network OS: Runs on a server and provides the server the capability to manage data, users, groups, security, applications, and other networking functions. \n6. Mobile OS: Designed specifically for mobile devices like smartphones and tablets. Examples include Android and iOS. They are optimized for touch interfaces and low-power consumption."
                },
                {
                    "name": "Functions and Services of OS",
                    "completed": false,
                    "details": "Operating systems provide several key functions and services: \n- Process Management: Creating, deleting, suspending, and resuming processes. \n- Memory Management: Allocating and deallocating memory space as required. \n- File System Management: Organizing files and directories, and controlling access to them. \n- I/O Device Management: Managing communication with hardware devices. \n- Security and Protection: Ensuring that resources are accessed only by authorized users and processes. \n- Networking: Enabling communication between computers. \n- User Interface: Providing a way for users to interact with the system (e.g., command-line interface, graphical user interface). \n- Error Detection and Handling: Detecting and responding to errors in hardware or software."
                },
                {
                    "name": "System Calls and APIs",
                    "completed": false,
                    "details": "System calls provide the interface between a process and the operating system. They are typically written in assembly language or C. When a process needs a service from the OS (e.g., reading a file, creating a new process), it executes a system call. This causes a trap to a specific location in the interrupt vector, and the OS takes over. An Application Programming Interface (API) is a higher-level set of functions that often wrap these system calls, making them easier for application programmers to use. Common APIs include Win32 API for Windows, POSIX API for UNIX-based systems, and Java API for Java virtual machine."
                },
                {
                    "name": "Monolithic vs Microkernel Architecture",
                    "completed": false,
                    "details": "Monolithic kernels have all OS services running in kernel space. This can lead to better performance as communication between modules is fast. However, a bug in one module can crash the entire system, and it's harder to extend. Examples include traditional UNIX and Linux. \nMicrokernels, on the other hand, have only essential services (like IPC and basic scheduling) in the kernel space. Other services (like file systems, device drivers) run as user-level server processes. This provides better modularity, security, and reliability, but can have performance overhead due to increased IPC. Examples include Mach and QNX."
                }
            ]
        },
        {
            "name": "Process Management",
            "subtopics": [
                {
                    "name": "Processes and Process States",
                    "completed": false,
                    "details": "A process is a program in execution. As a process executes, it changes state. The state of a process is defined in part by the current activity of that process. Each process may be in one ofthe following states: \n- New: The process is being created. \n- Ready: The process is waiting to be assigned to a processor. \n- Running: Instructions are being executed. \n- Waiting: The process is waiting for some event to occur (such as an I/O completion or reception of a signal). \n- Terminated: The process has finished execution. It's important to note that only one process can be running on any processor at any instant, though many processes may be ready and waiting."
                },
                {
                    "name": "Process Control Block (PCB)",
                    "completed": false,
                    "details": "Each process is represented in the operating system by a process control block (PCB)—also called a task control block. A PCB contains many pieces of information associated with a specific process, including: \n- Process state: The current state of the process (e.g., new, ready, running, waiting, terminated). \n- Program counter: Indicates the address of the next instruction to be executed for this process. \n- CPU registers: Vary in number and type, depending on the computer architecture. They include accumulators, index registers, stack pointers, and general-purpose registers, plus any condition-code information. \n- CPU-scheduling information: Includes a process priority, pointers to scheduling queues, and any other scheduling parameters. \n- Memory-management information: May include such information as the value of the base and limit registers, the page tables, or the segment tables, depending on the memory system used by the operating system. \n- Accounting information: Includes the amount of CPU and real time used, time limits, account numbers, job or process numbers, and so on. \n- I/O status information: Includes the list of I/O devices allocated to the process, a list of open files, and so on."
                },
                {
                    "name": "Context Switching",
                    "completed": false,
                    "details": "Switching the CPU to another process requires performing a state save of the current process and a state restore of a different process. This task is known as a context switch. Context-switch time is pure overhead, because the system does no useful work while switching. Its speed varies from machine to machine, depending on the memory speed, the number of registers that must be copied, and the existence of special instructions (such as a single instruction to load or store all registers). Context-switch times are highly dependent on hardware support. For instance, some processors provide multiple sets of registers. A context switch here simply requires changing the pointer to the current register set."
                }
            ]
        },
        {
            "name": "CPU Scheduling",
            "subtopics": [
                {
                    "name": "Scheduling Criteria & Metrics",
                    "completed": false,
                    "details": "Different CPU-scheduling algorithms have different properties, and the choice of a particular algorithm may favor one class of processes over another. Many criteria have been suggested for comparing CPU-scheduling algorithms. Which characteristics are used for comparison can make a substantial difference in which algorithm is judged to be best. Criteria include: \n- CPU utilization: Keep the CPU as busy as possible. \n- Throughput: The number of processes that are completed per time unit. \n- Turnaround time: The interval from the time of submission of a process to the time of completion. \n- Waiting time: The sum of the periods spent waiting in the ready queue. \n- Response time: The time from the submission of a request until the first response is produced (for time-sharing environment)."
                },
                {
                    "name": "Preemptive vs Non-Preemptive Scheduling",
                    "completed": false,
                    "details": "CPU scheduling decisions may take place under the following four circumstances: \n1. When a process switches from the running state to the waiting state. \n2. When a process switches from the running state to the ready state. \n3. When a process switches from the waiting state to the ready state. \n4. When a process terminates. \nFor situations 1 and 4, there is no choice in terms of scheduling. A new process (if one exists in the ready queue) must be selected for execution. There is a choice, however, for situations 2 and 3. When scheduling takes place only under circumstances 1 and 4, we say that the scheduling scheme is non-preemptive or cooperative. Otherwise, it is preemptive. Non-preemptive scheduling means that once the CPU has been allocated to a process, the process keeps the CPU until it releases the CPU either by terminating or by switching to the waiting state. Preemptive scheduling can result in race conditions when data are shared among several processes. This means that the OS may interrupt a running process and allocate the CPU to another process."
                }
            ]
        }
    ]
}
